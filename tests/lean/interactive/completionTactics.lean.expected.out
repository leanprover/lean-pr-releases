{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 10, "character": 20}}
{"items": [], "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 13, "character": 21}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 13, "character": 21}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 16, "character": 24}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 16, "character": 24}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 19, "character": 25}}
{"items": [], "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 22, "character": 26}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 22, "character": 26}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 25, "character": 27}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 25, "character": 27}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 28, "character": 30}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 28, "character": 30}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 33, "character": 7}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 33, "character": 7}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 37, "character": 2}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 37, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 42, "character": 2}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 42, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 46, "character": 2}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 46, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 52, "character": 4}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 52, "character": 4}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 57, "character": 2}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 57, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 63, "character": 4}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 63, "character": 4}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 69, "character": 2}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 69, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 74, "character": 4}}
{"items": [], "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 79, "character": 2}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 79, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 84, "character": 4}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 84, "character": 4}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 89, "character": 2}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 89, "character": 2}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 95, "character": 4}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 95, "character": 4}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 101, "character": 2}}
{"items": [], "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 106, "character": 12}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 106, "character": 12}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 113, "character": 4}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 113, "character": 4}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 120, "character": 4}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 120, "character": 4}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 125, "character": 4}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 125, "character": 4}}}}],
 "isIncomplete": true}
{"textDocument": {"uri": "file:///completionTactics.lean"},
 "position": {"line": 129, "character": 2}}
{"items":
 [{"sortText": "000",
   "label": "(",
   "kind": 14,
   "documentation":
   {"value":
    "`(tacs)` executes a list of tactics in sequence, without requiring that\nthe goal be closed at the end like `· tacs`. Like `by` itself, the tactics\ncan be either separated by newlines or `;`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "001",
   "label": "<;>",
   "kind": 14,
   "documentation":
   {"value":
    "`tac <;> tac'` runs `tac` on the main goal and `tac'` on each produced goal,\nconcatenating all goals produced by `tac'`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "002",
   "label": "ac_nf",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_nf` normalizes equalities up to application of an associative and commutative operator.\n- `ac_nf` normalizes all hypotheses and the goal target of the goal.\n- `ac_nf at l` normalizes at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by\n ac_nf\n -- goal: a + (b + (c + d)) = a + (b + (c + d))\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "003",
   "label": "ac_nf0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `ac_nf` (the full `ac_nf` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "004",
   "label": "ac_rfl",
   "kind": 14,
   "documentation":
   {"value":
    "`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Associative (α := Nat) (.+.) := ⟨Nat.add_assoc⟩\ninstance : Commutative (α := Nat) (.+.) := ⟨Nat.add_comm⟩\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "005",
   "label": "admit",
   "kind": 14,
   "documentation":
   {"value": "`admit` is a shorthand for `exact sorry`. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "006",
   "label": "all_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`all_goals tac` runs `tac` on each goal, concatenating the resulting goals, if any. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "007",
   "label": "and_intros",
   "kind": 14,
   "documentation":
   {"value":
    "`and_intros` applies `And.intro` until it does not make progress. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "008",
   "label": "any_goals",
   "kind": 14,
   "documentation":
   {"value":
    "`any_goals tac` applies the tactic `tac` to every goal, and succeeds if at\nleast one application succeeds.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "009",
   "label": "apply",
   "kind": 14,
   "documentation":
   {"value":
    "`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "010",
   "label": "apply?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can refine the goal using `apply`\nwith conditions resolved when possible with `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused when closing the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "011",
   "label": "apply_assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_assumption` looks for an assumption of the form `... → ∀ _, ... → head`\nwhere `head` matches the current goal.\n\nYou can specify additional rules to apply using `apply_assumption [...]`.\nBy default `apply_assumption` will also try `rfl`, `trivial`, `congrFun`, and `congrArg`.\nIf you don't want these, or don't want to use all hypotheses, use `apply_assumption only [...]`.\nYou can use `apply_assumption [-h]` to omit a local hypothesis.\nYou can use `apply_assumption using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`apply_assumption` will use consequences of local hypotheses obtained via `symm`.\n\nIf `apply_assumption` fails, it will call `exfalso` and try again.\nThus if there is an assumption of the form `P → ¬ Q`, the new tactic state\nwill have two goals, `P` and `Q`.\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...}) lemmas`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "012",
   "label": "apply_ext_theorem",
   "kind": 14,
   "documentation":
   {"value": "Apply a single extensionality theorem to the current goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "013",
   "label": "apply_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then `apply` the expression to the goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "014",
   "label": "apply_rfl",
   "kind": 14,
   "documentation":
   {"value": "The same as `rfl`, but without trying `eq_refl` at the end.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "015",
   "label": "apply_rules",
   "kind": 14,
   "documentation":
   {"value":
    "`apply_rules [l₁, l₂, ...]` tries to solve the main goal by iteratively\napplying the list of lemmas `[l₁, l₂, ...]` or by applying a local hypothesis.\nIf `apply` generates new goals, `apply_rules` iteratively tries to solve those goals.\nYou can use `apply_rules [-h]` to omit a local hypothesis.\n\n`apply_rules` will also use `rfl`, `trivial`, `congrFun` and `congrArg`.\nThese can be disabled, as can local hypotheses, by using `apply_rules only [...]`.\n\nYou can use `apply_rules using [a₁, ...]` to use all lemmas which have been labelled\nwith the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\nYou can pass a further configuration via the syntax `apply_rules (config := {...})`.\nThe options supported are the same as for `solve_by_elim` (and include all the options for `apply`).\n\n`apply_rules` will try calling `symm` on hypotheses and `exfalso` on the goal as needed.\nThis can be disabled with `apply_rules (config := {symm := false, exfalso := false})`.\n\nYou can bound the iteration depth using the syntax `apply_rules (config := {maxDepth := n})`.\n\nUnlike `solve_by_elim`, `apply_rules` does not perform backtracking, and greedily applies\na lemma from the list until it gets stuck.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "016",
   "label": "array_get_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf arr[i] < sizeOf arr`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "017",
   "label": "array_mem_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that `sizeOf a < sizeOf arr`\nprovided that `a ∈ arr` which is useful for well founded recursions over a nested inductive like\n`inductive T | mk : Array T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "018",
   "label": "assumption",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "019",
   "label": "assumption_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`assumption_mod_cast` is a variant of `assumption` that solves the goal\nusing a hypothesis. Unlike `assumption`, it first pre-processes the goal and\neach hypothesis to move casts as far outwards as possible, so it can be used\nin more situations.\n\nConcretely, it runs `norm_cast` on the goal. For each local hypothesis `h`, it also\nnormalizes `h` with `norm_cast` and tries to use that to close the goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "020",
   "label": "bv_omega",
   "kind": 14,
   "documentation":
   {"value":
    "`bv_omega` is `omega` with an additional preprocessor that turns statements about `BitVec` into statements about `Nat`.\nCurrently the preprocessor is implemented as `try simp only [bv_toNat] at *`.\n`bv_toNat` is a `@[simp]` attribute that you can (cautiously) add to more theorems.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "021",
   "label": "by_cases",
   "kind": 14,
   "documentation":
   {"value":
    "`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "022",
   "label": "calc",
   "kind": 14,
   "documentation":
   {"value":
    "Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `<lhs>\\n  _ = <rhs> :=\n<proof>`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "023",
   "label": "case",
   "kind": 14,
   "documentation":
   {"value":
    "* `case tag => tac` focuses on the goal with case name `tag` and solves it using `tac`,\n  or else fails.\n* `case tag x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses\n  with inaccessible names to the given names.\n* `case tag₁ | tag₂ => tac` is equivalent to `(case tag₁ => tac); (case tag₂ => tac)`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "024",
   "label": "case'",
   "kind": 14,
   "documentation":
   {"value":
    "`case'` is similar to the `case tag => tac` tactic, but does not ensure the goal\nhas been solved after applying `tac`, nor admits the goal if `tac` failed.\nRecall that `case` closes the goal using `sorry` when `tac` fails, and\nthe tactic execution is not interrupted.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "025",
   "label": "cases",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List α`, `cases as with | nil => tac₁ | cons a as' => tac₂`,\n  uses tactic `tac₁` for the `nil` case, and `tac₂` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "026",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change a with b` will change occurrences of `a` to `b` in the goal,\n  assuming `a` and `b` are definitionally equal.\n* `change a with b at h` similarly changes `a` to `b` in the type of hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "027",
   "label": "change",
   "kind": 14,
   "documentation":
   {"value":
    "* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "028",
   "label": "checkpoint",
   "kind": 14,
   "documentation":
   {"value":
    "`checkpoint tac` acts the same as `tac`, but it caches the input and output of `tac`,\nand if the file is re-elaborated and the input matches, the tactic is not re-run and\nits effects are reapplied to the state. This is useful for improving responsiveness\nwhen working on a long tactic proof, by wrapping expensive tactics with `checkpoint`.\n\nSee the `save` tactic, which may be more convenient to use.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "029",
   "label": "clean_wf",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic is used internally by lean before presenting the proof obligations from a well-founded\ndefinition to the user via `decreasing_by`. It is not necessary to use this tactic manually.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "030",
   "label": "clear",
   "kind": 14,
   "documentation":
   {"value":
    "`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "031",
   "label": "congr",
   "kind": 14,
   "documentation":
   {"value":
    "Apply congruence (recursively) to goals of the form `⊢ f as = f bs` and `⊢ HEq (f as) (f bs)`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `⊢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `⊢ x = y` and `⊢ y = x`,\nwhile `congr 2` produces the intended `⊢ x + y = y + x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "032",
   "label": "constructor",
   "kind": 14,
   "documentation":
   {"value":
    "If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "033",
   "label": "contradiction",
   "kind": 14,
   "documentation":
   {"value":
    "`contradiction` closes the main goal if its hypotheses are \"trivially contradictory\".\n\n- Inductive type/family with no applicable constructors\n  ```lean\n  example (h : False) : p := by contradiction\n  ```\n- Injectivity of constructors\n  ```lean\n  example (h : none = some true) : p := by contradiction  --\n  ```\n- Decidable false proposition\n  ```lean\n  example (h : 2 + 2 = 3) : p := by contradiction\n  ```\n- Contradictory hypotheses\n  ```lean\n  example (h : p) (h' : ¬ p) : q := by contradiction\n  ```\n- Other simple contradictions such as\n  ```lean\n  example (x : Nat) (h : x ≠ x) : p := by contradiction\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "034",
   "label": "conv",
   "kind": 14,
   "documentation":
   {"value":
    "`conv => ...` allows the user to perform targeted rewriting on a goal or hypothesis,\nby focusing on particular subexpressions.\n\nSee <https://lean-lang.org/theorem_proving_in_lean4/conv.html> for more details.\n\nBasic forms:\n* `conv => cs` will rewrite the goal with conv tactics `cs`.\n* `conv at h => cs` will rewrite hypothesis `h`.\n* `conv in pat => cs` will rewrite the first subexpression matching `pat` (see `pattern`).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "035",
   "label": "conv'",
   "kind": 14,
   "documentation":
   {"value":
    "Executes the given conv block without converting regular goal into a `conv` goal. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "036",
   "label": "dbg_trace",
   "kind": 14,
   "documentation":
   {"value":
    "`dbg_trace \"foo\"` prints `foo` when elaborated.\nUseful for debugging tactic control flow:\n```\nexample : False ∨ True := by\n  first\n  | apply Or.inl; trivial; dbg_trace \"left\"\n  | apply Or.inr; trivial; dbg_trace \"right\"\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "037",
   "label": "decreasing_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`decreasing_tactic` is called by default on well-founded recursions in order\nto synthesize a proof that recursive calls decrease along the selected\nwell founded relation. It can be locally overridden by using `decreasing_by tac`\non the recursive definition, and it can also be globally extended by adding\nmore definitions for `decreasing_tactic` (or `decreasing_trivial`,\nwhich this tactic calls). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "038",
   "label": "decreasing_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "Extensible helper tactic for `decreasing_tactic`. This handles the \"base case\"\nreasoning after applying lexicographic order lemmas.\nIt can be extended by adding more macro definitions, e.g.\n```\nmacro_rules | `(tactic| decreasing_trivial) => `(tactic| linarith)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "039",
   "label": "decreasing_trivial_pre_omega",
   "kind": 14,
   "documentation":
   {"value":
    "Variant of `decreasing_trivial` that does not use `omega`, intended to be used in core modules\nbefore `omega` is available.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "040",
   "label": "decreasing_with",
   "kind": 14,
   "documentation":
   {"value":
    "Constructs a proof of decreasing along a well founded relation, by simplifying, then applying\nlexicographic order lemmas and finally using `ts` to solve the base case. If it fails,\nit prints a message to help the user diagnose an ill-founded recursive definition. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "041",
   "label": "delta",
   "kind": 14,
   "documentation":
   {"value":
    "`delta id1 id2 ...` delta-expands the definitions `id1`, `id2`, ....\nThis is a low-level tactic, it will expose how recursive definitions have been\ncompiled by Lean.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "042",
   "label": "done",
   "kind": 14,
   "documentation":
   {"value": "`done` succeeds iff there are no remaining goals. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "043",
   "label": "dsimp",
   "kind": 14,
   "documentation":
   {"value":
    "The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "044",
   "label": "dsimp!",
   "kind": 14,
   "documentation":
   {"value":
    "`dsimp!` is shorthand for `dsimp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "045",
   "label": "dsimp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "046",
   "label": "dsimp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "047",
   "label": "eq_refl",
   "kind": 14,
   "documentation":
   {"value":
    "`eq_refl` is equivalent to `exact rfl`, but has a few optimizations. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "048",
   "label": "erw",
   "kind": 14,
   "documentation":
   {"value":
    "`erw [rules]` is a shorthand for `rw (config := { transparency := .default }) [rules]`.\nThis does rewriting up to unfolding of regular definitions (by comparison to regular `rw`\nwhich only unfolds `@[reducible]` definitions). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "049",
   "label": "exact",
   "kind": 14,
   "documentation":
   {"value":
    "`exact e` closes the main goal if its target type matches that of `e`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "050",
   "label": "exact?",
   "kind": 14,
   "documentation":
   {"value":
    "Searches environment for definitions or theorems that can solve the goal using `exact`\nwith conditions resolved by `solve_by_elim`.\n\nThe optional `using` clause provides identifiers in the local context that must be\nused by `exact?` when closing the goal.  This is most useful if there are multiple\nways to resolve the goal, and one wants to guide which lemma is used.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "051",
   "label": "exact_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Normalize casts in the goal and the given expression, then close the goal with `exact`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "052",
   "label": "exfalso",
   "kind": 14,
   "documentation":
   {"value":
    "`exfalso` converts a goal `⊢ tgt` into `⊢ False` by applying `False.elim`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "053",
   "label": "exists",
   "kind": 14,
   "documentation":
   {"value":
    "`exists e₁, e₂, ...` is shorthand for `refine ⟨e₁, e₂, ...⟩; try trivial`.\nIt is useful for existential goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "054",
   "label": "ext",
   "kind": 14,
   "documentation":
   {"value":
    "Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "055",
   "label": "ext1",
   "kind": 14,
   "documentation":
   {"value":
    "`ext1 pat*` is like `ext pat*` except that it only applies a single extensionality theorem rather\nthan recursively applying as many extensionality theorems as possible.\n\nThe `pat*` patterns are processed using the `rintro` tactic.\nIf no patterns are supplied, then variables are introduced anonymously using the `intros` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "056",
   "label": "fail",
   "kind": 14,
   "documentation":
   {"value":
    "`fail msg` is a tactic that always fails, and produces an error using the given message. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "057",
   "label": "fail_if_success",
   "kind": 14,
   "documentation":
   {"value": "`fail_if_success t` fails if the tactic `t` succeeds. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "058",
   "label": "false_or_by_contra",
   "kind": 14,
   "documentation":
   {"value":
    "Changes the goal to `False`, retaining as much information as possible:\n\n* If the goal is `False`, do nothing.\n* If the goal is an implication or a function type, introduce the argument and restart.\n  (In particular, if the goal is `x ≠ y`, introduce `x = y`.)\n* Otherwise, for a propositional goal `P`, replace it with `¬ ¬ P`\n  (attempting to find a `Decidable` instance, but otherwise falling back to working classically)\n  and introduce `¬ P`.\n* For a non-propositional goal use `False.elim`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "059",
   "label": "first",
   "kind": 14,
   "documentation":
   {"value":
    "`first | tac | ...` runs each `tac` until one succeeds, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "060",
   "label": "focus",
   "kind": 14,
   "documentation":
   {"value":
    "`focus tac` focuses on the main goal, suppressing all other goals, and runs `tac` on it.\nUsually `· tac`, which enforces that the goal is closed by `tac`, should be preferred.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "061",
   "label": "funext",
   "kind": 14,
   "documentation":
   {"value":
    "Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x => ...) = (fun x => ...))\n```\nThe variant `funext h₁ ... hₙ` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat × Bool => ...) = (fun x => ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "062",
   "label": "generalize",
   "kind": 14,
   "documentation":
   {"value":
    "* `generalize ([h :] e = x),+` replaces all occurrences `e`s in the main goal\n  with a fresh hypothesis `x`s. If `h` is given, `h : e = x` is introduced as well.\n* `generalize e = x at h₁ ... hₙ` also generalizes occurrences of `e`\n  inside `h₁`, ..., `hₙ`.\n* `generalize e = x at *` will generalize occurrences of `e` everywhere.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "063",
   "label": "get_elem_tactic",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic` is the tactic automatically called by the notation `arr[i]`\nto prove any side conditions that arise when constructing the term\n(e.g. the index is in bounds of the array). It just delegates to\n`get_elem_tactic_trivial` and gives a diagnostic error message otherwise;\nusers are encouraged to extend `get_elem_tactic_trivial` instead of this tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "064",
   "label": "get_elem_tactic_trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`get_elem_tactic_trivial` is an extensible tactic automatically called\nby the notation `arr[i]` to prove any side conditions that arise when\nconstructing the term (e.g. the index is in bounds of the array).\nThe default behavior is to just try `trivial` (which handles the case\nwhere `i < arr.size` is in the context) and `simp_arith` and `omega`\n(for doing linear arithmetic in the index).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "065",
   "label": "guard_expr",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check equality of two expressions.\n* `guard_expr e = e'` checks that `e` and `e'` are defeq at reducible transparency.\n* `guard_expr e =~ e'` checks that `e` and `e'` are defeq at default transparency.\n* `guard_expr e =ₛ e'` checks that `e` and `e'` are syntactically equal.\n* `guard_expr e =ₐ e'` checks that `e` and `e'` are alpha-equivalent.\n\nBoth `e` and `e'` are elaborated then have their metavariables instantiated before the equality\ncheck. Their types are unified (using `isDefEqGuarded`) before synthetic metavariables are\nprocessed, which helps with default instance handling.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "066",
   "label": "guard_hyp",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that a named hypothesis has a given type and/or value.\n\n* `guard_hyp h : t` checks the type up to reducible defeq,\n* `guard_hyp h :~ t` checks the type up to default defeq,\n* `guard_hyp h :ₛ t` checks the type up to syntactic equality,\n* `guard_hyp h :ₐ t` checks the type up to alpha equality.\n* `guard_hyp h := v` checks value up to reducible defeq,\n* `guard_hyp h :=~ v` checks value up to default defeq,\n* `guard_hyp h :=ₛ v` checks value up to syntactic equality,\n* `guard_hyp h :=ₐ v` checks the value up to alpha equality.\n\nThe value `v` is elaborated using the type of `h` as the expected type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "067",
   "label": "guard_target",
   "kind": 14,
   "documentation":
   {"value":
    "Tactic to check that the target agrees with a given expression.\n* `guard_target = e` checks that the target is defeq at reducible transparency to `e`.\n* `guard_target =~ e` checks that the target is defeq at default transparency to `e`.\n* `guard_target =ₛ e` checks that the target is syntactically equal to `e`.\n* `guard_target =ₐ e` checks that the target is alpha-equivalent to `e`.\n\nThe term `e` is elaborated with the type of the goal as the expected type, which is mostly\nuseful within `conv` mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "068",
   "label": "have",
   "kind": 14,
   "documentation":
   {"value":
    "The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "069",
   "label": "have'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `have`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "070",
   "label": "haveI",
   "kind": 14,
   "documentation":
   {"value":
    "`haveI` behaves like `have`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "071",
   "label": "induction",
   "kind": 14,
   "documentation":
   {"value":
    "Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih₁ : P a → Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih₁` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z₁ ... zₙ`, where `z₁ ... zₙ` are variables in the local context,\n  generalizes over `z₁ ... zₙ` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero => tac₁ | succ x' ih => tac₂`\n  uses tactic `tac₁` for the `zero` case, and `tac₂` for the `succ` case.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "072",
   "label": "infer_instance",
   "kind": 14,
   "documentation":
   {"value":
    "`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "073",
   "label": "injection",
   "kind": 14,
   "documentation":
   {"value":
    "The `injection` tactic is based on the fact that constructors of inductive data\ntypes are injections.\nThat means that if `c` is a constructor of an inductive datatype, and if `(c t₁)`\nand `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.\nIf `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies\ninjectivity to derive the equality of all arguments of `t₁` and `t₂` placed in\nthe same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`.\nTo use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.\nGiven `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types\n`a = c` and `b = d` to the main goal.\nThe tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "074",
   "label": "injections",
   "kind": 14,
   "documentation":
   {"value":
    "`injections` applies `injection` to all hypotheses recursively\n(since `injection` can produce new hypotheses). Useful for destructing nested\nconstructor equalities like `(a::b::c) = (d::e::f)`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "075",
   "label": "intro",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 => tac\n  | ...\n  ```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "076",
   "label": "intros",
   "kind": 14,
   "documentation":
   {"value":
    "Introduces zero or more hypotheses, optionally naming them.\n\n- `intros` is equivalent to repeatedly applying `intro`\n  until the goal is not an obvious candidate for `intro`, which is to say\n  that so long as the goal is a `let` or a pi type (e.g. an implication, function, or universal quantifier),\n  the `intros` tactic will introduce an anonymous hypothesis.\n  This tactic does not unfold definitions.\n\n- `intros x y ...` is equivalent to `intro x y ...`,\n  introducing hypotheses for each supplied argument and unfolding definitions as necessary.\n  Each argument can be either an identifier or a `_`.\n  An identifier indicates a name to use for the corresponding introduced hypothesis,\n  and a `_` indicates that the hypotheses should be introduced anonymously.\n\n## Examples\n\nBasic properties:\n```lean\ndef AllEven (f : Nat → Nat) := ∀ n, f n % 2 = 0\n\n-- Introduces the two obvious hypotheses automatically\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros\n  /- Tactic state\n     f✝ : Nat → Nat\n     a✝ : AllEven f✝\n     ⊢ AllEven fun k => f✝ (k + 1) -/\n  sorry\n\n-- Introduces exactly two hypotheses, naming only the first\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros g _\n  /- Tactic state\n     g : Nat → Nat\n     a✝ : AllEven g\n     ⊢ AllEven fun k => g (k + 1) -/\n  sorry\n\n-- Introduces exactly three hypotheses, which requires unfolding `AllEven`\nexample : ∀ (f : Nat → Nat), AllEven f → AllEven (fun k => f (k + 1)) := by\n  intros f h n\n  /- Tactic state\n     f : Nat → Nat\n     h : AllEven f\n     n : Nat\n     ⊢ (fun k => f (k + 1)) n % 2 = 0 -/\n  apply h\n```\n\nImplications:\n```lean\nexample (p q : Prop) : p → q → p := by\n  intros\n  /- Tactic state\n     a✝¹ : p\n     a✝ : q\n     ⊢ p      -/\n  assumption\n```\n\nLet bindings:\n```lean\nexample : let n := 1; let k := 2; n + k = 3 := by\n  intros\n  /- n✝ : Nat := 1\n     k✝ : Nat := 2\n     ⊢ n✝ + k✝ = 3 -/\n  rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "077",
   "label": "iterate",
   "kind": 14,
   "documentation":
   {"value":
    "`iterate n tac` runs `tac` exactly `n` times.\n`iterate tac` runs `tac` repeatedly until failure.\n\n`iterate`'s argument is a tactic sequence,\nso multiple tactics can be run using `iterate n (tac₁; tac₂; ⋯)` or\n```lean\niterate n\n  tac₁\n  tac₂\n  ⋯\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "078",
   "label": "Lean.cdot",
   "kind": 14,
   "documentation":
   {"value":
    "`· tac` focuses on the main goal and tries to solve it using `tac`, or else fails. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "079",
   "label": "Lean.Parser.Tactic.decide",
   "kind": 14,
   "documentation":
   {"value":
    "`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nLimitations:\n- The target is not allowed to contain local variables or metavariables.\n  If there are local variables, you can try first using the `revert` tactic with these local variables\n  to move them into the target, which may allow `decide` to succeed.\n- Because this uses kernel reduction to evaluate the term, `Decidable` instances defined\n  by well-founded recursion might not work, because evaluating them requires reducing proofs.\n  The kernel can also get stuck reducing `Decidable` instances with `Eq.rec` terms for rewriting propositions.\n  These can appear for instances defined using tactics (such as `rw` and `simp`).\n  To avoid this, use definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "080",
   "label": "Lean.Parser.Tactic.introMatch",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic\n```\nintro\n| pat1 => tac1\n| pat2 => tac2\n```\nis the same as:\n```\nintro x\nmatch x with\n| pat1 => tac1\n| pat2 => tac2\n```\nThat is, `intro` can be followed by match arms and it introduces the values while\ndoing a pattern match. This is equivalent to `fun` with match arms in term mode.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "081",
   "label": "Lean.Parser.Tactic.match",
   "kind": 14,
   "documentation":
   {"value":
    "`match` performs case analysis on one or more expressions.\nSee [Induction and Recursion][tpil4].\nThe syntax for the `match` tactic is the same as term-mode `match`, except that\nthe match arms are tactics instead of expressions.\n```\nexample (n : Nat) : n = n := by\n  match n with\n  | 0 => rfl\n  | i+1 => simp\n```\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/induction_and_recursion.html\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "082",
   "label": "Lean.Parser.Tactic.nativeDecide",
   "kind": 14,
   "documentation":
   {"value":
    "`native_decide` will attempt to prove a goal of type `p` by synthesizing an instance\nof `Decidable p` and then evaluating it to `isTrue ..`. Unlike `decide`, this\nuses `#eval` to evaluate the decidability instance.\n\nThis should be used with care because it adds the entire lean compiler to the trusted\npart, and the axiom `ofReduceBool` will show up in `#print axioms` for theorems using\nthis method or anything that transitively depends on them. Nevertheless, because it is\ncompiled, this can be significantly more efficient than using `decide`, and for very\nlarge computations this is one way to run external programs and trust the result.\n```\nexample : (List.range 1000).length = 1000 := by native_decide\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "083",
   "label": "Lean.Parser.Tactic.nestedTactic",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "084",
   "label": "Lean.Parser.Tactic.open",
   "kind": 14,
   "documentation":
   {"value":
    "`open Foo in tacs` (the tactic) acts like `open Foo` at command level,\nbut it opens a namespace only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "085",
   "label": "Lean.Parser.Tactic.set_option",
   "kind": 14,
   "documentation":
   {"value":
    "`set_option opt val in tacs` (the tactic) acts like `set_option opt val` at the command level,\nbut it sets the option only within the tactics `tacs`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "086",
   "label": "Lean.Parser.Tactic.tacDepIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if h : t then tac1 else tac2` can be used as alternative syntax for:\n```\nby_cases h : t\n· tac1\n· tac2\n```\nIt performs case distinction on `h : t` or `h : ¬t` and `tac1` and `tac2` are the subproofs.\n\nYou can use `?_` or `_` for either subproof to delay the goal to after the tactic, but\nif a tactic sequence is provided for `tac1` or `tac2` then it will require the goal to be closed\nby the end of the block.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "087",
   "label": "Lean.Parser.Tactic.tacIfThenElse",
   "kind": 14,
   "documentation":
   {"value":
    "In tactic mode, `if t then tac1 else tac2` is alternative syntax for:\n```\nby_cases t\n· tac1\n· tac2\n```\nIt performs case distinction on `h† : t` or `h† : ¬t`, where `h†` is an anonymous\nhypothesis, and `tac1` and `tac2` are the subproofs. (It doesn't actually use\nnondependent `if`, since this wouldn't add anything to the context and hence would be\nuseless for proving theorems. To actually insert an `ite` application use\n`refine if t then ?_ else ?_`.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "088",
   "label": "Lean.Parser.Tactic.unknown",
   "kind": 14,
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "089",
   "label": "left",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ∨ False := by\n  left\n  trivial\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "090",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "The `let` tactic is for adding definitions to the local context of the main goal.\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat => _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : α × β × γ`, `let ⟨x, y, z⟩ := p` produces the\n  local variables `x : α`, `y : β`, and `z : γ`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "091",
   "label": "let",
   "kind": 14,
   "documentation":
   {"value":
    "`let rec f : t := e` adds a recursive definition `f` to the current goal.\nThe syntax is the same as term-mode `let rec`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "092",
   "label": "let'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `let`, but using `refine'` ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "093",
   "label": "letI",
   "kind": 14,
   "documentation":
   {"value":
    "`letI` behaves like `let`, but inlines the value instead of producing a `let_fun` term. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "094",
   "label": "next",
   "kind": 14,
   "documentation":
   {"value":
    "`next => tac` focuses on the next goal and solves it using `tac`, or else fails.\n`next x₁ ... xₙ => tac` additionally renames the `n` most recent hypotheses with\ninaccessible names to the given names.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "095",
   "label": "nofun",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `nofun` is shorthand for `exact nofun`: it introduces the assumptions, then performs an\nempty pattern match, closing the goal if the introduced pattern is impossible.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "096",
   "label": "nomatch",
   "kind": 14,
   "documentation":
   {"value": "The tactic `nomatch h` is shorthand for `exact nomatch h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "097",
   "label": "norm_cast",
   "kind": 14,
   "documentation":
   {"value":
    "The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ℤ\nh : ↑a + ↑b < (10 : ℚ)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b < 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "098",
   "label": "norm_cast0",
   "kind": 14,
   "documentation":
   {"value":
    "Implementation of `norm_cast` (the full `norm_cast` calls `trivial` afterwards). ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "099",
   "label": "obtain",
   "kind": 14,
   "documentation":
   {"value":
    "The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ⟨patt⟩ : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ⟨patt⟩\n```\n\nIf `⟨patt⟩` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "100",
   "label": "omega",
   "kind": 14,
   "documentation":
   {"value":
    "The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x < y`, `x ≤ y`, and `k ∣ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega (config :=\n  { splitDisjunctions := true, splitNatSub := true, splitNatAbs := true, splitMinMax := true })\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ≤ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ≤ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ∨ min a b = b`\nCurrently, all of these are on by default.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "101",
   "label": "push_cast",
   "kind": 14,
   "documentation":
   {"value":
    "`push_cast` rewrites the goal to move certain coercions (*casts*) inward, toward the leaf nodes.\nThis uses `norm_cast` lemmas in the forward direction.\nFor example, `↑(a + b)` will be written to `↑a + ↑b`.\n- `push_cast` moves casts inward in the goal.\n- `push_cast at h` moves casts inward in the hypothesis `h`.\nIt can be used with extra simp lemmas with, for example, `push_cast [Int.add_zero]`.\n\nExample:\n```lean\nexample (a b : Nat)\n    (h1 : ((a + b : Nat) : Int) = 10)\n    (h2 : ((a + b + 0 : Nat) : Int) = 10) :\n    ((a + b : Nat) : Int) = 10 := by\n  /-\n  h1 : ↑(a + b) = 10\n  h2 : ↑(a + b + 0) = 10\n  ⊢ ↑(a + b) = 10\n  -/\n  push_cast\n  /- Now\n  ⊢ ↑a + ↑b = 10\n  -/\n  push_cast at h1\n  push_cast [Int.add_zero] at h2\n  /- Now\n  h1 h2 : ↑a + ↑b = 10\n  -/\n  exact h1\n```\n\nSee also `norm_cast`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "102",
   "label": "rcases",
   "kind": 14,
   "documentation":
   {"value":
    "`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ∧ b ∧ c ∨ d` or\n`h2 : ∃ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ⟨ha, hb, hc⟩ | hd` or\n`rcases h2 with ⟨x, y, _ | ⟨z, hxz, hzy⟩⟩` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `⟨p1, p2, p3⟩`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ∧ b ∧ c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@⟨p1, p2, p3⟩` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ∨ b ∨ c`.\n\nA pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `⟨a, b, c⟩` for splitting on\n`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "103",
   "label": "refine",
   "kind": 14,
   "documentation":
   {"value":
    "`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "104",
   "label": "refine'",
   "kind": 14,
   "documentation":
   {"value":
    "`refine' e` behaves like `refine e`, except that unsolved placeholders (`_`)\nand implicit parameters are also converted into new goals.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "105",
   "label": "refine_lift",
   "kind": 14,
   "documentation":
   {"value":
    "Auxiliary macro for lifting have/suffices/let/...\nIt makes sure the \"continuation\" `?_` is the main goal after refining.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "106",
   "label": "refine_lift'",
   "kind": 14,
   "documentation":
   {"value": "Similar to `refine_lift`, but using `refine'` ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "107",
   "label": "rename",
   "kind": 14,
   "documentation":
   {"value":
    "`rename t => x` renames the most recent hypothesis whose type matches `t`\n(which may contain placeholders) to `x`, or fails if no such hypothesis could be found.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "108",
   "label": "rename_i",
   "kind": 14,
   "documentation":
   {"value":
    "`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "109",
   "label": "repeat",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat tac` repeatedly applies `tac` so long as it succeeds.\nThe tactic `tac` may be a tactic sequence, and if `tac` fails at any point in its execution,\n`repeat` will revert any partial changes that `tac` made to the tactic state.\n\nThe tactic `tac` should eventually fail, otherwise `repeat tac` will run indefinitely.\n\nSee also:\n* `try tac` is like `repeat tac` but will apply `tac` at most once.\n* `repeat' tac` recursively applies `tac` to each goal.\n* `first | tac1 | tac2` implements the backtracking used by `repeat`\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "110",
   "label": "repeat'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat' tac` recursively applies `tac` on all of the goals so long as it succeeds.\nThat is to say, if `tac` produces multiple subgoals, then `repeat' tac` is applied to each of them.\n\nSee also:\n* `repeat tac` simply repeatedly applies `tac`.\n* `repeat1' tac` is `repeat' tac` but requires that `tac` succeed for some goal at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "111",
   "label": "repeat1'",
   "kind": 14,
   "documentation":
   {"value":
    "`repeat1' tac` recursively applies to `tac` on all of the goals so long as it succeeds,\nbut `repeat1' tac` fails if `tac` succeeds on none of the initial goals.\n\nSee also:\n* `repeat tac` simply applies `tac` repeatedly.\n* `repeat' tac` is like `repeat1' tac` but it does not require that `tac` succeed at least once.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "112",
   "label": "replace",
   "kind": 14,
   "documentation":
   {"value":
    "Acts like `have`, but removes a hypothesis with the same name as\nthis one if possible. For example, if the state is:\n\n```lean\nf : α → β\nh : α\n⊢ goal\n```\n\nThen after `replace h := f h` the state will be:\n\n```lean\nf : α → β\nh : β\n⊢ goal\n```\n\nwhereas `have h := f h` would result in:\n\n```lean\nf : α → β\nh† : α\nh : β\n⊢ goal\n```\n\nThis can be used to simulate the `specialize` and `apply at` tactics of Coq.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "113",
   "label": "revert",
   "kind": 14,
   "documentation":
   {"value":
    "`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "114",
   "label": "rewrite",
   "kind": 14,
   "documentation":
   {"value":
    "`rewrite [e]` applies identity `e` as a rewrite rule to the target of the main goal.\nIf `e` is preceded by left arrow (`←` or `<-`), the rewrite is applied in the reverse direction.\nIf `e` is a defined constant, then the equational theorems associated with `e` are used.\nThis provides a convenient way to unfold `e`.\n- `rewrite [e₁, ..., eₙ]` applies the given rules sequentially.\n- `rewrite [e] at l` rewrites `e` at location(s) `l`, where `l` is either `*` or a\n  list of hypotheses in the local context. In the latter case, a turnstile `⊢` or `|-`\n  can also be used, to signify the target of the goal.\n\nUsing `rw (config := {occs := .pos L}) [e]`,\nwhere `L : List Nat`, you can control which \"occurrences\" are rewritten.\n(This option applies to each rule, so usually this will only be used with a single rule.)\nOccurrences count from `1`.\nAt each allowed occurrence, arguments of the rewrite rule `e` may be instantiated,\nrestricting which later rewrites can be found.\n(Disallowed occurrences do not result in instantiation.)\n`{occs := .neg L}` allows skipping specified occurrences.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "115",
   "label": "rfl",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "116",
   "label": "rfl'",
   "kind": 14,
   "documentation":
   {"value":
    "`rfl'` is similar to `rfl`, but disables smart unfolding and unfolds all kinds of definitions,\ntheorems included (relevant for declarations defined by well-founded recursion).\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "117",
   "label": "right",
   "kind": 14,
   "documentation":
   {"value":
    "Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ∨ q := by\n  right\n  exact h\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "118",
   "label": "rintro",
   "kind": 14,
   "documentation":
   {"value":
    "The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "119",
   "label": "rotate_left",
   "kind": 14,
   "documentation":
   {"value":
    "`rotate_left n` rotates goals to the left by `n`. That is, `rotate_left 1`\ntakes the main goal and puts it to the back of the subgoal list.\nIf `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "120",
   "label": "rotate_right",
   "kind": 14,
   "documentation":
   {"value":
    "Rotate the goals to the right by `n`. That is, take the goal at the back\nand push it to the front `n` times. If `n` is omitted, it defaults to `1`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "121",
   "label": "run_tac",
   "kind": 14,
   "documentation":
   {"value": "The `run_tac doSeq` tactic executes code in `TacticM Unit`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "122",
   "label": "rw",
   "kind": 14,
   "documentation":
   {"value":
    "`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "123",
   "label": "rw?",
   "kind": 14,
   "documentation":
   {"value":
    "`rw?` tries to find a lemma which can rewrite the goal.\n\n`rw?` should not be left in proofs; it is a search tool, like `apply?`.\n\nSuggestions are printed as `rw [h]` or `rw [← h]`.\n\nYou can use `rw? [-my_lemma, -my_theorem]` to prevent `rw?` using the named lemmas.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "124",
   "label": "rw_mod_cast",
   "kind": 14,
   "documentation":
   {"value":
    "Rewrites with the given rules, normalizing casts prior to each step.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "125",
   "label": "rwa",
   "kind": 14,
   "documentation":
   {"value":
    "`rwa` calls `rw`, then closes any remaining goals using `assumption`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "126",
   "label": "save",
   "kind": 14,
   "documentation":
   {"value":
    "`save` is defined to be the same as `skip`, but the elaborator has\nspecial handling for occurrences of `save` in tactic scripts and will transform\n`by tac1; save; tac2` to `by (checkpoint tac1); tac2`, meaning that the effect of `tac1`\nwill be cached and replayed. This is useful for improving responsiveness\nwhen working on a long tactic proof, by using `save` after expensive tactics.\n\n(TODO: do this automatically and transparently so that users don't have to use\nthis combinator explicitly.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "127",
   "label": "show",
   "kind": 14,
   "documentation":
   {"value":
    "`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "128",
   "label": "show_term",
   "kind": 14,
   "documentation":
   {"value":
    "`show_term tac` runs `tac`, then prints the generated term in the form\n\"exact X Y Z\" or \"refine X ?_ Z\" if there are remaining subgoals.\n\n(For some tactics, the printed term will not be human readable.)\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "129",
   "label": "simp",
   "kind": 14,
   "documentation":
   {"value":
    "The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "130",
   "label": "simp!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp!` is shorthand for `simp` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "131",
   "label": "simp?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "132",
   "label": "simp?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "133",
   "label": "simp_all",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "134",
   "label": "simp_all!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all!` is shorthand for `simp_all` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "135",
   "label": "simp_all?",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "136",
   "label": "simp_all?!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp?` takes the same arguments as `simp`, but reports an equivalent call to `simp only`\nthat would be sufficient to close the goal. This is useful for reducing the size of the simp\nset in a local invocation to speed up processing.\n```\nexample (x : Nat) : (if True then x + 2 else 3) = x + 2 := by\n  simp? -- prints \"Try this: simp only [ite_true]\"\n```\n\nThis command can also be used in `simp_all` and `dsimp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "137",
   "label": "simp_all_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith` combines the effects of `simp_all` and `simp_arith`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "138",
   "label": "simp_all_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_all_arith!` combines the effects of `simp_all`, `simp_arith` and `simp!`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "139",
   "label": "simp_arith",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith` is shorthand for `simp` with `arith := true` and `decide := true`.\nThis enables the use of normalization by linear arithmetic. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "140",
   "label": "simp_arith!",
   "kind": 14,
   "documentation":
   {"value":
    "`simp_arith!` is shorthand for `simp_arith` with `autoUnfold := true`.\nThis will rewrite with all equation lemmas, which can be used to\npartially evaluate many definitions. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "141",
   "label": "simp_wf",
   "kind": 14,
   "documentation":
   {"value":
    "Unfold definitions commonly used in well founded relation definitions.\n\nSince Lean 4.12, Lean unfolds these definitions automatically before presenting the goal to the\nuser, and this tactic should no longer be necessary. Calls to `simp_wf` can be removed or replaced\nby plain calls to `simp`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "142",
   "label": "simpa",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "143",
   "label": "simpa!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "144",
   "label": "simpa?",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "145",
   "label": "simpa?!",
   "kind": 14,
   "documentation":
   {"value":
    "This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ⋯] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ⋯]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "146",
   "label": "sizeOf_list_dec",
   "kind": 14,
   "documentation":
   {"value":
    "This tactic, added to the `decreasing_trivial` toolbox, proves that\n`sizeOf a < sizeOf as` when `a ∈ as`, which is useful for well founded recursions\nover a nested inductive like `inductive T | mk : List T → T`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "147",
   "label": "skip",
   "kind": 14,
   "documentation": {"value": "`skip` does nothing. ", "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "148",
   "label": "sleep",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `sleep ms` sleeps for `ms` milliseconds and does nothing.\nIt is used for debugging purposes only.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "149",
   "label": "solve",
   "kind": 14,
   "documentation":
   {"value":
    "Similar to `first`, but succeeds only if one the given tactics solves the current goal.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "150",
   "label": "solve_by_elim",
   "kind": 14,
   "documentation":
   {"value":
    "`solve_by_elim` calls `apply` on the main goal to find an assumption whose head matches\nand then repeatedly calls `apply` on the generated subgoals until no subgoals remain,\nperforming at most `maxDepth` (defaults to 6) recursive steps.\n\n`solve_by_elim` discharges the current goal or fails.\n\n`solve_by_elim` performs backtracking if subgoals can not be solved.\n\nBy default, the assumptions passed to `apply` are the local context, `rfl`, `trivial`,\n`congrFun` and `congrArg`.\n\nThe assumptions can be modified with similar syntax as for `simp`:\n* `solve_by_elim [h₁, h₂, ..., hᵣ]` also applies the given expressions.\n* `solve_by_elim only [h₁, h₂, ..., hᵣ]` does not include the local context,\n  `rfl`, `trivial`, `congrFun`, or `congrArg` unless they are explicitly included.\n* `solve_by_elim [-h₁, ... -hₙ]` removes the given local hypotheses.\n* `solve_by_elim using [a₁, ...]` uses all lemmas which have been labelled\n  with the attributes `aᵢ` (these attributes must be created using `register_label_attr`).\n\n`solve_by_elim*` tries to solve all goals together, using backtracking if a solution for one goal\nmakes other goals impossible.\n(Adding or removing local hypotheses may not be well-behaved when starting with multiple goals.)\n\nOptional arguments passed via a configuration argument as `solve_by_elim (config := { ... })`\n- `maxDepth`: number of attempts at discharging generated subgoals\n- `symm`: adds all hypotheses derived by `symm` (defaults to `true`).\n- `exfalso`: allow calling `exfalso` and trying again if `solve_by_elim` fails\n  (defaults to `true`).\n- `transparency`: change the transparency mode when calling `apply`. Defaults to `.default`,\n  but it is often useful to change to `.reducible`,\n  so semireducible definitions will not be unfolded when trying to apply a lemma.\n\nSee also the doc-comment for `Lean.Meta.Tactic.Backtrack.BacktrackConfig` for the options\n`proc`, `suspend`, and `discharge` which allow further customization of `solve_by_elim`.\nBoth `apply_assumption` and `apply_rules` are implemented via these hooks.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "151",
   "label": "sorry",
   "kind": 14,
   "documentation":
   {"value":
    "The `sorry` tactic closes the goal using `sorryAx`. This is intended for stubbing out incomplete\nparts of a proof while still having a syntactically correct proof skeleton. Lean will give\na warning whenever a proof uses `sorry`, so you aren't likely to miss it, but\nyou can double check if a theorem depends on `sorry` by using\n`#print axioms my_thm` and looking for `sorryAx` in the axiom list.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "152",
   "label": "specialize",
   "kind": 14,
   "documentation":
   {"value":
    "The tactic `specialize h a₁ ... aₙ` works on local hypothesis `h`.\nThe premises of this hypothesis, either universal quantifications or\nnon-dependent implications, are instantiated by concrete terms coming\nfrom arguments `a₁` ... `aₙ`.\nThe tactic adds a new hypothesis with the same name `h := h a₁ ... aₙ`\nand tries to clear the previous one.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "153",
   "label": "split",
   "kind": 14,
   "documentation":
   {"value":
    "The `split` tactic is useful for breaking nested if-then-else and `match` expressions into separate cases.\nFor a `match` expression with `n` cases, the `split` tactic generates at most `n` subgoals.\n\nFor example, given `n : Nat`, and a target `if n = 0 then Q else R`, `split` will generate\none goal with hypothesis `n = 0` and target `Q`, and a second goal with hypothesis\n`¬n = 0` and target `R`.  Note that the introduced hypothesis is unnamed, and is commonly\nrenamed used the `case` or `next` tactics.\n\n- `split` will split the goal (target).\n- `split at h` will split the hypothesis `h`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "154",
   "label": "stop",
   "kind": 14,
   "documentation":
   {"value":
    "`stop` is a helper tactic for \"discarding\" the rest of a proof:\nit is defined as `repeat sorry`.\nIt is useful when working on the middle of a complex proofs,\nand less messy than commenting the remainder of the proof.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "155",
   "label": "subst",
   "kind": 14,
   "documentation":
   {"value":
    "`subst x...` substitutes each `x` with `e` in the goal if there is a hypothesis\nof type `x = e` or `e = x`.\nIf `x` is itself a hypothesis of type `y = e` or `e = y`, `y` is substituted instead.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "156",
   "label": "subst_eqs",
   "kind": 14,
   "documentation":
   {"value":
    "`subst_eq` repeatedly substitutes according to the equality proof hypotheses in the context,\nreplacing the left side of the equality with the right, until no more progress can be made.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "157",
   "label": "subst_vars",
   "kind": 14,
   "documentation":
   {"value":
    "Applies `subst` to all hypotheses of the form `h : x = t` or `h : t = x`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "158",
   "label": "suffices",
   "kind": 14,
   "documentation":
   {"value":
    "Given a main goal `ctx ⊢ t`, `suffices h : t' from e` replaces the main goal with `ctx ⊢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "159",
   "label": "symm",
   "kind": 14,
   "documentation":
   {"value":
    "* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "160",
   "label": "symm_saturate",
   "kind": 14,
   "documentation":
   {"value":
    "For every hypothesis `h : a ~ b` where a `@[symm]` lemma is available,\nadd a hypothesis `h_symm : b ~ a`. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "161",
   "label": "trace",
   "kind": 14,
   "documentation":
   {"value": "`trace msg` displays `msg` in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "162",
   "label": "trace_state",
   "kind": 14,
   "documentation":
   {"value": "`trace_state` displays the current state in the info view. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "163",
   "label": "trivial",
   "kind": 14,
   "documentation":
   {"value":
    "`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) => `(tactic| simp)\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "164",
   "label": "try",
   "kind": 14,
   "documentation":
   {"value": "`try tac` runs `tac` and succeeds even if `tac` failed. ",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "165",
   "label": "unfold",
   "kind": 14,
   "documentation":
   {"value":
    "* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "166",
   "label": "unhygienic",
   "kind": 14,
   "documentation":
   {"value":
    "`unhygienic tacs` runs `tacs` with name hygiene disabled.\nThis means that tactics that would normally create inaccessible names will instead\nmake regular variables. **Warning**: Tactics may change their variable naming\nstrategies at any time, so code that depends on autogenerated names is brittle.\nUsers should try not to use `unhygienic` if possible.\n```\nexample : ∀ x : Nat, x = x := by unhygienic\n  intro            -- x would normally be intro'd as inaccessible\n  exact Eq.refl x  -- refer to x\n```\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "167",
   "label": "with_reducible",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible tacs` executes `tacs` using the reducible transparency setting.\nIn this setting only definitions tagged as `[reducible]` are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "168",
   "label": "with_reducible_and_instances",
   "kind": 14,
   "documentation":
   {"value":
    "`with_reducible_and_instances tacs` executes `tacs` using the `.instances` transparency setting.\nIn this setting only definitions tagged as `[reducible]` or type class instances are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}},
  {"sortText": "169",
   "label": "with_unfolding_all",
   "kind": 14,
   "documentation":
   {"value":
    "`with_unfolding_all tacs` executes `tacs` using the `.all` transparency setting.\nIn this setting all definitions that are not opaque are unfolded.\n",
    "kind": "markdown"},
   "data":
   {"params":
    {"textDocument": {"uri": "file:///completionTactics.lean"},
     "position": {"line": 129, "character": 2}}}}],
 "isIncomplete": true}
